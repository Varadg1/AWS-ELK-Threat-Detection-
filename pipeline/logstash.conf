input {
  # CloudTrail logs
  s3 {
    bucket           => "cloudsentinellogs-1.0"
    region           => "us-east-1"
    access_key_id    => ${AWS_ACCESS_KEY_ID}
    secret_access_key=> ${AWS_SECRET_ACCESS_KEY}
    prefix           => "AWSLogs/422772905291/CloudTrail/"
    type             => "cloudtrail"
    codec            => "json"
    sincedb_path     => "/usr/share/logstash/data/s3_sincedb_cloudtrail"
  }

  # VPC Flow logs
  s3 {
    bucket           => "cloudsentinellogs-1.0"
    region           => "us-east-1"
    access_key_id    => ${AWS_ACCESS_KEY_ID}
    secret_access_key=> ${AWS_SECRET_ACCESS_KEY}
    prefix           => "vpcflow/AWSLogs/422772905291/vpcflowlogs/"
    interval         => 15
    type             => "vpcflow"
    codec            => "plain"
    sincedb_path     => "/usr/share/logstash/data/s3_sincedb_vpcflow"
  }
}

filter {
  ######################################################################
  # CloudTrail parsing with FIXED user.name extraction
  ######################################################################
  if [type] == "cloudtrail" {
    json {
      source => "message"
      skip_on_invalid_json => true
    }

    split {
      field  => "Records"
      target => "record"
    }

    # Basic field extraction
    mutate {
      rename => {
        "[record][userIdentity][type]"           => "[user][type]"
        "[record][eventName]"                    => "eventName"
        "[record][eventSource]"                  => "eventSource"
        "[record][sourceIPAddress]"              => "[source][ip]"
        "[record][userAgent]"                    => "[user_agent][original]"
        "[record][awsRegion]"                    => "[cloud][region]"
        "[record][requestParameters][policyArn]" => "policyArn"
        "[record][errorCode]"                    => "errorCode"
      }
      add_field => { "log_type" => "cloudtrail" }
    }

    # FIXED user.name field creation with proper fallback logic
    if [record][userIdentity][userName] and [record][userIdentity][userName] != "" {
      # If userName exists, use it
      mutate {
        add_field => { "[user][name]" => "%{[record][userIdentity][userName]}" }
      }
    } else if [record][userIdentity][type] == "Root" {
      # For Root users, create a consistent name
      mutate {
        add_field => { "[user][name]" => "root" }
      }
    } else if [record][userIdentity][principalId] {
      # Fallback to principalId for other user types
      mutate {
        add_field => { "[user][name]" => "%{[record][userIdentity][principalId]}" }
      }
    } else {
      # Last resort fallback
      mutate {
        add_field => { "[user][name]" => "unknown" }
      }
    }

    # GeoIP enrichment
    if [source][ip] and [source][ip] != "-" {
      geoip {
        source => "[source][ip]"
        target => "[source][geo]"
      }
    }

    # UEBA tagging for privileged actions
    if [eventName] in ["CreateUser", "CreateRole", "AttachUserPolicy", "AttachRolePolicy",
                       "PutUserPolicy", "PutRolePolicy", "DeleteUser", "DeleteRole"] {
      mutate { add_tag => ["privileged_action"] }
    }

    # Tag root user activity
    if [user][type] == "Root" {
      mutate { add_tag => ["root_activity"] }
    }

    # Tag security group changes
    if [eventName] in ["AuthorizeSecurityGroupIngress", "AuthorizeSecurityGroupEgress",
                       "RevokeSecurityGroupIngress", "RevokeSecurityGroupEgress"] {
      mutate { add_tag => ["security_group_change"] }
    }

    mutate {
      remove_field => ["message", "record"]
    }
  }

  ######################################################################
  # BULLETPROOF VPC Flow processing - Handles all data quality issues
  ######################################################################
  if [type] == "vpcflow" {
    # Skip header lines and malformed entries
    if [message] =~ /^version/ or [message] =~ /^account-id/ or [message] == "" {
      drop { }
    }

    if [message] !~ /^[0-9]/ {
      drop { }
    }

    grok {
      match => {
        "message" => "%{DATA:version} %{DATA:account_id} %{DATA:interface_id} %{DATA:srcaddr} %{DATA:dstaddr} %{DATA:srcport} %{DATA:dstport} %{DATA:protocol} %{DATA:packets} %{DATA:bytes} %{DATA:start} %{DATA:end} %{DATA:action} %{DATA:log_status}"
      }
      tag_on_failure => ["_grokparsefailure_vpcflow"]
    }

    if "_grokparsefailure_vpcflow" not in [tags] {
      # BULLETPROOF field conversion - handles nil, empty, and invalid values

      # Convert srcport with full validation
      if [srcport] and [srcport] != "-" and [srcport] != "" and [srcport] =~ /^[0-9]+$/ {
        mutate { convert => { "srcport" => "integer" } }
      } else {
        mutate { replace => { "srcport" => "0" } }
        mutate { convert => { "srcport" => "integer" } }
      }

      # Convert dstport with full validation
      if [dstport] and [dstport] != "-" and [dstport] != "" and [dstport] =~ /^[0-9]+$/ {
        mutate { convert => { "dstport" => "integer" } }
      } else {
        mutate { replace => { "dstport" => "0" } }
        mutate { convert => { "dstport" => "integer" } }
      }

      # Convert protocol with full validation
      if [protocol] and [protocol] != "-" and [protocol] != "" and [protocol] =~ /^[0-9]+$/ {
        mutate { convert => { "protocol" => "integer" } }
      } else {
        mutate { replace => { "protocol" => "0" } }
        mutate { convert => { "protocol" => "integer" } }
      }

      # Convert packets with full validation
      if [packets] and [packets] != "-" and [packets] != "" and [packets] =~ /^[0-9]+$/ {
        mutate { convert => { "packets" => "integer" } }
      } else {
        mutate { replace => { "packets" => "0" } }
        mutate { convert => { "packets" => "integer" } }
      }

      # Convert bytes with full validation
      if [bytes] and [bytes] != "-" and [bytes] != "" and [bytes] =~ /^[0-9]+$/ {
        mutate { convert => { "bytes" => "integer" } }
      } else {
        mutate { replace => { "bytes" => "0" } }
        mutate { convert => { "bytes" => "integer" } }
      }

      # GeoIP enrichment for external IPs only
      if [srcaddr] and [srcaddr] != "-" and [srcaddr] != "" and [srcaddr] !~ /^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.)/ {
        geoip {
          source => "srcaddr"
          target => "[source][geo]"
        }
        mutate {
          add_field => { "[source][ip]" => "%{srcaddr}" }
        }
      }

      # Map destination IP
      if [dstaddr] and [dstaddr] != "-" and [dstaddr] != "" {
        mutate {
          add_field => { "[destination][ip]" => "%{dstaddr}" }
        }
      }

      ######################################################################
      # WEB SERVER SECURITY MONITORING (Port 80 & 443)
      ######################################################################
      if [dstport] == 80 or [dstport] == 443 {
        mutate {
          add_tag => ["web_server_traffic", "http_traffic"]
          add_field => { "webserver_port" => "%{dstport}" }
        }

        # GEOGRAPHIC THREAT DETECTION
        if [source][geo][country_name] in ["China", "North Korea", "Pakistan"] {
          mutate {
            add_tag => ["restricted_country_access", "high_risk_geo", "geographic_threat"]
            add_field => {
              "security_risk_level" => "critical"
              "threat_type" => "geographic_restriction_violation"
              "alert_priority" => "high"
            }
          }
        }

        # DDOS ATTACK DETECTION
        if [bytes] and [bytes] > 50000 {
          mutate {
            add_tag => ["high_volume_request", "ddos_indicator", "bandwidth_anomaly"]
            add_field => { "ddos_indicator" => "high_bytes" }
          }
        }

        if [packets] and [packets] > 1000 {
          mutate {
            add_tag => ["high_packet_count", "ddos_indicator", "flood_attack"]
            add_field => { "ddos_indicator" => "packet_flood" }
          }
        }

        # Connection analysis
        if [action] == "ACCEPT" {
          mutate {
            add_tag => ["successful_connection", "web_access"]
            add_field => { "connection_status" => "accepted" }
          }
        } else if [action] == "REJECT" {
          mutate {
            add_tag => ["blocked_connection", "potential_attack"]
            add_field => {
              "connection_status" => "rejected"
              "threat_type" => "blocked_access_attempt"
            }
          }
        }

        # Protocol identification
        if [protocol] == 6 {
          mutate {
            add_tag => ["tcp_traffic", "web_protocol"]
            add_field => { "protocol_name" => "TCP" }
          }
        }
      }

      # High-risk port detection
      if [dstport] in [22, 3389, 1433, 3306, 5432, 21, 23, 25] {
        mutate {
          add_tag => ["admin_port_access", "privileged_service", "high_risk_port"]
          add_field => { "port_risk_level" => "high" }
        }
      }

      # Large transfer detection
      if [bytes] and [bytes] > 1000000 {
        mutate {
          add_tag => ["high_volume_transfer", "data_exfiltration_risk"]
          add_field => { "data_volume_status" => "suspicious" }
        }
      }

      # Final cleanup
      mutate {
        add_field => {
          "log_type" => "vpcflow"
          "network_direction" => "inbound"
        }
        remove_field => ["message"]
      }
    } else {
      drop { }
    }
  }
}

output {
  if [log_type] == "cloudtrail" {
    elasticsearch {
      hosts    => ["http://elasticsearch:9200"]
      user     => ${ELASTIC_USERNAME}
      password => ${ELASTIC_PASSWORD}
      index    => "cloudtrail-%{+YYYY.MM.dd}"
    }
  }

  if [log_type] == "vpcflow" {
    elasticsearch {
      hosts    => ["http://elasticsearch:9200"]
      user     => ${ELASTIC_USERNAME}
      password => ${ELASTIC_PASSWORD}
      index    => "vpcflow-%{+YYYY.MM.dd}"
    }
  }
}
